/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "capacidade.h"
#include "lib_restaurante.h"
#include <syslog.h>
#include <string.h>

/** Initializes the capacidade module */
void
init_capacidade(void)
{
    const oid capacidade_oid[] = { 1,3,6,1,4,1,12619,1 };

  DEBUGMSGTL(("capacidade", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("capacidade", handle_capacidade,
                               capacidade_oid, OID_LENGTH(capacidade_oid),
                               HANDLER_CAN_RONLY
        ));
}

/*
 * handle_capacidade(...)
 * 
 * Funcao responsavel por obter a capacidade maxima do restaurante. Ela faz uma chamada ao programa auxiliar restaurante.py,
 * e analisa o resultado dessa chamada.
 * O codigo dessa funcao foi quase todo gerado automaticamente pelo software mib2c, sendo somente necessario modificar algumas partes.
 * 
 */
int
handle_capacidade(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
       
    FILE *output;
    char app_path[120] = APP_PYTHON_PATH;				//Caminho para executar o software auxiliar	
    char buffer[BUFF_SIZE];
    unsigned long cap;
    
    switch(reqinfo->mode) {
		
        case MODE_GET:
			strcat(app_path, "-m");						// Concatena na string o argumento necessario para o software auxiliar
			output = popen (app_path, "r"); 			// Faz a chamada ao aplicativo, e analisa o resultado
			if (!output)
			{
				syslog (LOG_INFO,"incorrect parameters or too many files.\n");
				return EXIT_FAILURE;
			}
			// A leitura deve ser de apenas um string representando a capacidade maxima do restaurante
			fgets(buffer, BUFF_SIZE, output);
			// Converte o string em unsigned long
			cap = strtoul(buffer, NULL, 10);
			pclose(output);
			
			// Atualiza o objeto 
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, &cap, sizeof(cap));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_capacidade\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
